import { ethers } from 'ethers';
export interface ExtendedContract extends ethers.Contract {
    [key: string]: any;
    setDelegatedSigner?: (signerAddress: string) => Promise<ethers.ContractTransaction>;
    setMultiSigners?: (signers: string[], threshold: number, merkleRoot: string) => Promise<ethers.ContractTransaction>;
    setEmergencyStop?: (stopped: boolean) => Promise<ethers.ContractTransaction>;
    revokeRole?: (role: string, account: string) => Promise<ethers.ContractTransaction>;
    handleOps?: (userOps: any[], beneficiary: string) => Promise<ethers.ContractTransaction>;
    hasRole?: (role: string, account: string) => Promise<boolean>;
    getMessageHash?: (message: string) => Promise<string>;
    toEthSignedMessageHash?: (hash: string) => Promise<string>;
    isValidSignature?: (hash: string, signature: string) => Promise<string>;
    getNonce?: () => Promise<ethers.BigNumber>;
    emergencyStopped?: () => Promise<boolean>;
    transferERC20?: (token: string, amount: ethers.BigNumberish, recipient: string, targetChainId: ethers.BigNumberish, adapterParams?: string) => Promise<ethers.ContractTransaction>;
    transferERC721?: (token: string, tokenId: ethers.BigNumberish, recipient: string, targetChainId: ethers.BigNumberish, adapterParams?: string) => Promise<ethers.ContractTransaction>;
    transferERC1155?: (token: string, tokenIds: ethers.BigNumberish[], amounts: ethers.BigNumberish[], recipient: string, targetChainId: ethers.BigNumberish, adapterParams?: string) => Promise<ethers.ContractTransaction>;
    estimateCrossChainFee?: (token: string, amount: ethers.BigNumberish, targetChainId: ethers.BigNumberish, adapterParams?: string, tokenIds?: ethers.BigNumberish[], amounts?: ethers.BigNumberish[]) => Promise<ethers.BigNumber>;
    addSupportedToken?: (token: string, metadata: any) => Promise<ethers.ContractTransaction>;
    removeSupportedToken?: (token: string) => Promise<ethers.ContractTransaction>;
    addCrossChainAdapter?: (adapter: string, priority: number) => Promise<ethers.ContractTransaction>;
    removeCrossChainAdapter?: (adapter: string) => Promise<ethers.ContractTransaction>;
    updateAdapterPriority?: (adapter: string, priority: number) => Promise<ethers.ContractTransaction>;
    updateAdapterPerformance?: (adapter: string, success: boolean, latency: number) => Promise<ethers.ContractTransaction>;
    setFeeRecipient?: (feeRecipient: string) => Promise<ethers.ContractTransaction>;
    setFeePercentage?: (feePercentage: number) => Promise<ethers.ContractTransaction>;
    getSupportedTokens?: () => Promise<string[]>;
    getSupportedChains?: () => Promise<number[]>;
    getAdapters?: () => Promise<string[]>;
    getAdapterPriority?: (adapter: string) => Promise<number>;
    getAdapterPerformance?: (adapter: string) => Promise<any>;
    getFeeRecipient?: () => Promise<string>;
    getFeePercentage?: () => Promise<number>;
    isSupportedToken?: (token: string) => Promise<boolean>;
    isSupportedChain?: (chainId: number) => Promise<boolean>;
    createWallet?: (user: string, userId: string, threshold: string | number, brokers: string[], data?: string) => Promise<ethers.ContractTransaction>;
    upgradeImplementation?: (newImplementation: string) => Promise<ethers.ContractTransaction>;
    setEntryPoint?: (newEntryPoint: string) => Promise<ethers.ContractTransaction>;
    setPaymaster?: (newPaymaster: string) => Promise<ethers.ContractTransaction>;
    setTimelock?: (newTimelock: string) => Promise<ethers.ContractTransaction>;
    getWalletAddress?: (user: string) => Promise<string>;
    getWalletImplementation?: () => Promise<string>;
    getEntryPoint?: () => Promise<string>;
    getPaymaster?: () => Promise<string>;
    getTimelock?: () => Promise<string>;
    depositEth?: (userAddressOrOverrides?: string | {
        value: ethers.BigNumberish;
    }, overrides?: any) => Promise<ethers.ContractTransaction>;
    depositToken?: (userAddress: string, amount: ethers.BigNumberish) => Promise<ethers.ContractTransaction>;
    setFeeTier?: (userAddress: string, tier: number) => Promise<ethers.ContractTransaction>;
    setGasToken?: (tokenAddress: string) => Promise<ethers.ContractTransaction>;
    setOffPeakDiscount?: (startHour: number, endHour: number, discount: number) => Promise<ethers.ContractTransaction>;
    setVolumeDiscount?: (threshold: number, discount: number) => Promise<ethers.ContractTransaction>;
    setLowBalanceThresholds?: (ethThreshold: ethers.BigNumberish, tokenThreshold: ethers.BigNumberish) => Promise<ethers.ContractTransaction>;
    setFactory?: (factoryAddress: string) => Promise<ethers.ContractTransaction>;
    withdrawFunds?: (recipient: string, amount: ethers.BigNumberish, token: string) => Promise<ethers.ContractTransaction>;
    getBalance?: (userAddress: string, token: string) => Promise<ethers.BigNumber>;
    getFeeTier?: (userAddress: string) => Promise<number>;
    getGasToken?: () => Promise<string>;
    getOffPeakDiscount?: () => Promise<any>;
    getVolumeDiscount?: () => Promise<any>;
    getLowBalanceThresholds?: () => Promise<any>;
    isLowBalance?: (userAddress: string) => Promise<boolean>;
    calculateGasFee?: (gasUsed: ethers.BigNumberish, gasPrice: ethers.BigNumberish) => Promise<ethers.BigNumber>;
    addGuardian?: (guardianAddress: string, weight: number) => Promise<ethers.ContractTransaction>;
    removeGuardian?: (guardianAddress: string) => Promise<ethers.ContractTransaction>;
    updateGuardianWeight?: (guardianAddress: string, weight: number) => Promise<ethers.ContractTransaction>;
    setRecoveryThreshold?: (threshold: number) => Promise<ethers.ContractTransaction>;
    setRecoveryDelay?: (delay: number) => Promise<ethers.ContractTransaction>;
    setRecoveryExpiry?: (expiry: number) => Promise<ethers.ContractTransaction>;
    initiateRecovery?: (newOwner: string) => Promise<ethers.ContractTransaction>;
    supportRecovery?: (requestId: number) => Promise<ethers.ContractTransaction>;
    cancelRecovery?: (requestId: number) => Promise<ethers.ContractTransaction>;
    executeRecovery?: (requestId: number) => Promise<ethers.ContractTransaction>;
    submitRecoveryProof?: (requestId: number, guardian: string, signature: string, data?: string) => Promise<ethers.ContractTransaction>;
    recoveryRequests?: (requestId: number) => Promise<any>;
    guardians?: (guardianAddress: string) => Promise<any>;
    getActiveGuardians?: () => Promise<string[]>;
    recoveryThreshold?: () => Promise<ethers.BigNumber>;
    recoveryDelay?: () => Promise<ethers.BigNumber>;
    recoveryExpiry?: () => Promise<ethers.BigNumber>;
    nextRecoveryRequestId?: () => Promise<ethers.BigNumber>;
    isRecoveryRequestValid?: (requestId: number) => Promise<boolean>;
    isRecoveryRequestReady?: (requestId: number) => Promise<boolean>;
    recoverySupport?: (requestId: number, guardianAddress: string) => Promise<boolean>;
    depositERC20?: (tokenAddress: string, amount: ethers.BigNumberish) => Promise<ethers.ContractTransaction>;
    depositERC721?: (tokenAddress: string, tokenId: ethers.BigNumberish) => Promise<ethers.ContractTransaction>;
    depositERC1155?: (tokenAddress: string, tokenId: ethers.BigNumberish, amount: ethers.BigNumberish, data?: string) => Promise<ethers.ContractTransaction>;
    withdrawEth?: (recipient: string, amount: ethers.BigNumberish) => Promise<ethers.ContractTransaction>;
    withdrawERC20?: (tokenAddress: string, recipient: string, amount: ethers.BigNumberish) => Promise<ethers.ContractTransaction>;
    withdrawERC721?: (tokenAddress: string, recipient: string, tokenId: ethers.BigNumberish) => Promise<ethers.ContractTransaction>;
    withdrawERC1155?: (tokenAddress: string, recipient: string, tokenId: ethers.BigNumberish, amount: ethers.BigNumberish, data?: string) => Promise<ethers.ContractTransaction>;
    approveERC20?: (tokenAddress: string, spender: string, amount: ethers.BigNumberish) => Promise<ethers.ContractTransaction>;
    approveERC721?: (tokenAddress: string, operator: string, approved: boolean) => Promise<ethers.ContractTransaction>;
    approveERC1155?: (tokenAddress: string, operator: string, approved: boolean) => Promise<ethers.ContractTransaction>;
    executeTokenTransfer?: (tokenAddress: string, to: string, value: ethers.BigNumberish, data?: string) => Promise<ethers.ContractTransaction>;
    tokenApprovals?: (tokenAddress: string, spender: string) => Promise<{
        allowance: ethers.BigNumber;
        isApprovedForAll: boolean;
    }>;
    getTokenAllowance?: (tokenAddress: string, spender: string) => Promise<{
        allowance: ethers.BigNumber;
        isApprovedForAll: boolean;
    }>;
    getTokenBalance?: (tokenAddress: string, tokenId?: ethers.BigNumberish) => Promise<{
        balance: ethers.BigNumber;
        tokenType: number;
    }>;
    getOwnedTokens?: () => Promise<string[]>;
    getOwnedERC721Tokens?: (tokenAddress: string) => Promise<ethers.BigNumber[]>;
    getOwnedERC1155Tokens?: (tokenAddress: string) => Promise<any>;
    blacklistedTokens?: (tokenAddress: string) => Promise<boolean>;
    blacklistToken?: (tokenAddress: string) => Promise<ethers.ContractTransaction>;
    unblacklistToken?: (tokenAddress: string) => Promise<ethers.ContractTransaction>;
}
export declare function createExtendedContract(address: string, abi: any, provider: any): ExtendedContract;
